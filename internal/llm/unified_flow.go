package llm

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/BetterCallFirewall/Hackerecon/internal/models"
	"github.com/firebase/genkit/go/ai"
	genkitcore "github.com/firebase/genkit/go/core"
	"github.com/firebase/genkit/go/genkit"
)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Post-processing utilities for technical fields
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// enrichObservation populates exchange_id field
// id and created_at are auto-generated by storage.AddObservation()
// Business fields (what, where, why) are already filled by LLM
func enrichObservation(obs *models.Observation, exchangeID string) {
	if obs.ExchangeID == "" {
		obs.ExchangeID = exchangeID
	}
	// id and created_at are handled by storage layer
}

// enrichConnection populates technical fields (id1, id2, created_at)
// Business field (reason) is already filled by LLM
func enrichConnection(conn *models.Connection, id1, id2 string) {
	if conn.ID1 == "" {
		conn.ID1 = id1
	}
	if conn.ID2 == "" {
		conn.ID2 = id2
	}
	if conn.CreatedAt.IsZero() {
		conn.CreatedAt = time.Now()
	}
}

// enrichLead populates technical fields (id, observation_id, created_at)
// Business fields (title, actionable_step, pocs) are already filled by LLM
func enrichLead(lead *models.Lead, observationID string) {
	if lead.ID == "" {
		lead.ID = fmt.Sprintf("lead-%d", time.Now().UnixNano())
	}
	if lead.ObservationID == "" {
		lead.ObservationID = observationID
	}
	if lead.CreatedAt.IsZero() {
		lead.CreatedAt = time.Now()
	}
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Unified Analysis Flow - Atomic Genkit Flow
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// DefineUnifiedAnalysisFlow creates an atomic Genkit flow for unified analysis
// This flow replaces Phases 2+3+4 (Reasoning + Planning + Acting) with a single LLM call
func DefineUnifiedAnalysisFlow(
	g *genkit.Genkit,
	modelName string,
) *genkitcore.Flow[*UnifiedAnalysisRequest, *UnifiedAnalysisResponse, struct{}] {
	return genkit.DefineFlow(
		g,
		"unifiedAnalysisFlow",
		func(ctx context.Context, req *UnifiedAnalysisRequest) (*UnifiedAnalysisResponse, error) {
			log.Printf("ğŸ” Starting unified analysis for %s %s", req.Exchange.Request.Method, req.Exchange.Request.URL)

			// Build prompt
			prompt := BuildUnifiedAnalysisPrompt(req)

			// Execute LLM call using genkit.GenerateData
			log.Printf("ğŸ¤– Calling LLM for unified analysis")
			result, _, err := genkit.GenerateData[UnifiedAnalysisResponse](
				ctx,
				g,
				ai.WithModelName(modelName),
				ai.WithPrompt(prompt),
				ai.WithMiddleware(getMiddlewares()...),
			)
			if err != nil {
				return nil, fmt.Errorf("LLM generation failed: %w", err)
			}

			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			// Post-processing: populate technical fields that LLM doesn't generate
			// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			// Enrich all observations with exchange_id
			for i := range result.Observations {
				enrichObservation(&result.Observations[i], req.Exchange.ID)
			}

			// For connections, we can't auto-populate id1/id2 without more context
			// They should be populated by the caller or left empty if not needed
			for i := range result.Connections {
				if result.Connections[i].CreatedAt.IsZero() {
					result.Connections[i].CreatedAt = time.Now()
				}
			}

			log.Printf("âœ… Unified analysis complete: comment=%s, observations_count=%d, connections_count=%d",
				result.Comment, len(result.Observations), len(result.Connections))

			return result, nil
		},
	)
}
